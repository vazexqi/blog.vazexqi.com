--- 
layout: post
typo_id: 241
title: GTD for programmers.
---
<p><a href="http://www.43folders.com/2006/10/17/robert-peake-part-one/">Guest Post: DavidCo's Robert Peake on "Getting Software Done" (part 1) | 43 Folders</a>:

</p>



<blockquote cite="http://www.43folders.com/2006/10/17/robert-peake-part-one/" title="Guest Post: DavidCo's Robert Peake on "Getting Software Done" (part 1) | 43 Folderss"> "GTD in this way also provides the ultimate "safety net" for making sure stuff doesn't slip through the cracks. Sure, the act of programming in itself is highly linear: you run down the path until you have satisfied your test cases, then you move on to the next thing. However, in addition to bookmarking your progress along the path so that you can get right back to what's important after an interruption, GTD also gives you a complete, trusted inventory of all of the very next steps along all possible paths. Combined with an overall strategy (obviously), this means you can program with greater confidence and peace of mind - can run down the trail knowing it is the perfect trail for you to be running down at this moment - because you have scanned all the other options first, and know this course to be the best. Life, especially the life of a developer, is an open-ended, unknown tree. And the breadth-first approach of GTD is necessarily the most efficient option for traversing that tree."

</blockquote>



<p>
The above is an interesting read on how GTD might be applicable to programmers. The author is a programmer with a degree in poetry so that might explain his metaphorical examples. 
</p>

<p>
Be sure to check out the <a href="http://www.43folders.com/2006/10/18/robert-peake-part-two/">second part</a> to this post that compares GTD to Extreme Programming.
</p>
