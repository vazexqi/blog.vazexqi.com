--- 
layout: post
typo_id: 74
title: Learning LISP
---
<p>
After reading Paul Graham's essays and his bias in favor of Lisp, I finally joined in the bandwagon. Surprisingly, WikiPedia has this to say about Lisp:
<blockquote>
Having declined somewhat in the 1990s, Lisp has experienced a regrowth of interest since 2000, partly due to the writings of Paul Graham.
</blockquote>
I never knew that <i>he</i> had that much influence. Well, anyway, I picked up a copy of the Little LISPer from the library. Unfortunately, this book is no longer available for sale (it has been replaced by the Little Schemer, which I hear has about the same contents). Now, the Little LISPer is an interesting book. Instead of having page after page of words, it has page after page of conversations! Each page is formatted into two columns, one for the dialogue of the teacher and the other for the student. And their conversation revolves around LISP, recursion (lots of it) and food! For a sample of what these conversations sound like, I direct you to <a href="http://www.visibleworkings.com/little-ruby/">Brian Marick's</a> implementation of this style of writing for Ruby.
</p><p>
LISP seems to be an interesting language. So far the Little LISPer has focused more on recursion than features of the language, so I am not able to see how to use LISP to do more complex stuff. There are libraries written for it that can do GUI because it was in the tutorial for my IDE. I have also ordered a copy of <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0133708756/qid=1122190974/sr=8-1/ref=pd_bbs_sbs_1/103-0300846-2604644?v=glance&s=books&n=507846">ANSI Common LISP</a> from the library. Paul Graham <a href="http://www.paulgraham.com/acl.html">promises</a> that it has the best explanation for macros. And it even has 20 substantial examples for showcasing the power of LISP.
</p><p>
Anyway, my motivation for learning LISP is to verify how much of what Paul Graham says is true. He believes that languages are evolving more toward what LISP is. Here is a diagram that shows how Ruby came about. I pilfered it from the book
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0133708756/qid=1122190974/sr=8-1/ref=pd_bbs_sbs_1/103-0300846-2604644?v=glance&s=books&n=507846">Game Programming with Lua, Python and Ruby</a>. I sincerely hope that you do not buy this book. I have browsed through it and am really disappointed with its contents. Then again, I have never been pleased with the Game Developer series; the book lacks depth and tries to make up for it by having a CD that is loaded with all kinds of crap. The reviews for it on Amazon agrees with me. But, anyway, here is the diagram:
<br /><img alt="Ruby Evolution" src="http://photos22.flickr.com/32844685_04100fdb50.jpg?v=0"/></p><p>
No doubt, lambda (or Proc, as they are called in Ruby) seems to the common ground for this languages. Not to mention the fact that metaprogramming is an important feature for LISP. One, that paved the way for its popularity in Artificial Intelligence. Why (yes he is called Why or rather Why, the lucky stiff) has written two nice articles on metaprogramming on Ruby: <a href="http://whytheluckystiff.net/articles/seeingMetaclassesClearly.html"><i>Seeing Metaclass Clearly</i></a> and <a href="http://poignantguide.net/ruby/chapter-6.html#section3"><i>A Sponsored Dragon-Slaying</i></a>.
</p><p>
So, right now, the method that I am deploying for learning LISP falls along the lines of writing little programs and some test cases for them. This methodology is similar to the one suggested by <a href="http://www.clarkware.com/cgi/blosxom/2005/03/18">Mike Clark</a>. And for my IDE, I chose <a href="http://www.lispworks.com/downloads/">LISPWorks Personal Edition</a> as it was recommended on the LISP newsgroup.
</p>
